"""
WebSocket integration tests for multi-participant chat system.
Tests connection lifecycle, message flow, sync mechanism, broadcast, and error handling.
"""

import asyncio
import json
import time
import uuid
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional, Set
import pytest
import pytest_asyncio
from unittest.mock import Mock, AsyncMock, patch, MagicMock
import websockets
from websockets.exceptions import ConnectionClosed, InvalidHandshake

# Add parent directory to path
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../code/python'))

from chat.schemas import (
    ChatMessage, MessageType, MessageStatus,
    ParticipantInfo, ParticipantType, QueueFullError
)


# WebSocket Test Configuration
WS_BASE_URL = "ws://localhost:8080"
TEST_TIMEOUT = 10.0


class MockWebSocketClient:
    """Mock WebSocket client for testing."""
    
    def __init__(self, conversation_id: str, participant_id: str, auth_token: str):
        self.conversation_id = conversation_id
        self.participant_id = participant_id
        self.auth_token = auth_token
        self.websocket = None
        self.received_messages = []
        self.connection_attempts = 0
        self.is_connected = False
        self.last_sequence_id = 0
        
    async def connect(self):
        """Connect to WebSocket with authentication."""
        self.connection_attempts += 1
        
        # Mock WebSocket connection
        self.websocket = AsyncMock()
        self.websocket.send = AsyncMock()
        self.websocket.recv = AsyncMock()
        self.websocket.close = AsyncMock()
        self.websocket.closed = False
        
        # Simulate connection success
        self.is_connected = True
        return True
    
    async def send_message(self, content: str, sites: List[str] = None, mode: str = "list"):
        """Send a message through WebSocket."""
        if not self.is_connected:
            raise ConnectionClosed(None, None)
        
        message = {
            "type": "message",
            "content": content,
            "message_id": f"msg_{uuid.uuid4().hex[:8]}",
            "sites": sites or ["example.com"],
            "mode": mode
        }
        
        try:
            await self.websocket.send(json.dumps(message))
        except ConnectionClosed:
            # Mark connection as closed on error
            self.is_connected = False
            raise
        
        return message
    
    async def send_typing(self, is_typing: bool):
        """Send typing indicator."""
        if not self.is_connected:
            raise ConnectionClosed(None, None)
        
        typing_msg = {
            "type": "typing",
            "isTyping": is_typing
        }
        
        await self.websocket.send(json.dumps(typing_msg))
    
    async def send_sync_request(self):
        """Send sync request after reconnection."""
        sync_msg = {
            "type": "sync",
            "last_sequence_id": self.last_sequence_id
        }
        
        await self.websocket.send(json.dumps(sync_msg))
    
    async def receive_message(self):
        """Receive a message from WebSocket."""
        if not self.is_connected:
            raise ConnectionClosed(None, None)
        
        # Mock receiving a message
        mock_message = {
            "type": "message",
            "id": f"msg_{uuid.uuid4().hex[:8]}",
            "sequence_id": len(self.received_messages) + 1,
            "participant": {
                "participantId": "other_user",
                "displayName": "Other User",
                "type": "human"
            },
            "content": "Test message",
            "timestamp": datetime.utcnow().isoformat(),
            "conversation_id": self.conversation_id
        }
        
        self.received_messages.append(mock_message)
        self.last_sequence_id = mock_message["sequence_id"]
        return json.dumps(mock_message)
    
    async def disconnect(self):
        """Disconnect from WebSocket."""
        if self.websocket:
            await self.websocket.close()
        self.is_connected = False
    
    async def simulate_network_interruption(self):
        """Simulate network interruption."""
        self.is_connected = False
        if self.websocket:
            self.websocket.closed = True


@pytest.fixture
async def mock_ws_client():
    """Create a mock WebSocket client."""
    client = MockWebSocketClient("conv_test_001", "user_test_123", "Bearer test_token")
    yield client
    await client.disconnect()


@pytest.fixture
def multiple_mock_clients():
    """Create multiple mock WebSocket clients."""
    clients = []
    for i in range(3):
        client = MockWebSocketClient(
            conversation_id="conv_multi_001",
            participant_id=f"user_{i}",
            auth_token=f"Bearer token_{i}"
        )
        clients.append(client)
    return clients


@pytest.mark.integration
@pytest.mark.asyncio
class TestWebSocketConnectionLifecycle:
    """Test WebSocket connection lifecycle."""
    
    async def test_successful_handshake_with_auth(self, mock_ws_client):
        """Test successful WebSocket handshake with authentication."""
        # Test connection
        success = await mock_ws_client.connect()
        
        assert success is True
        assert mock_ws_client.is_connected is True
        assert mock_ws_client.connection_attempts == 1
        
        # Verify WebSocket was created
        assert mock_ws_client.websocket is not None
    
    async def test_multiple_humans_connecting_to_same_conversation(self, multiple_mock_clients):
        """Test multiple humans connecting to the same conversation."""
        # Connect all clients
        connection_results = []
        for client in multiple_mock_clients:
            result = await client.connect()
            connection_results.append(result)
        
        # All should connect successfully
        assert all(connection_results)
        assert all(client.is_connected for client in multiple_mock_clients)
        
        # All should be in same conversation
        conversation_ids = {client.conversation_id for client in multiple_mock_clients}
        assert len(conversation_ids) == 1
        assert "conv_multi_001" in conversation_ids
    
    async def test_reconnection_with_exponential_backoff(self, mock_ws_client):
        """Test reconnection with exponential backoff."""
        # Initial connection
        await mock_ws_client.connect()
        assert mock_ws_client.is_connected
        
        # Simulate network interruption
        await mock_ws_client.simulate_network_interruption()
        assert not mock_ws_client.is_connected
        
        # Test exponential backoff reconnection
        backoff_times = [1, 2, 4, 8, 16, 30]  # Max 30s
        
        for expected_backoff in backoff_times[:3]:  # Test first 3 attempts
            start_time = time.time()
            
            # Simulate backoff delay
            await asyncio.sleep(0.01)  # Short delay for testing
            
            # Attempt reconnection
            await mock_ws_client.connect()
            
            elapsed = time.time() - start_time
            # In real implementation, would verify actual backoff timing
            assert mock_ws_client.connection_attempts > 1
    
    async def test_connection_limit_enforcement(self):
        """Test connection limit enforcement."""
        # Mock scenario where connection limit is reached
        with patch('websockets.connect') as mock_connect:
            mock_connect.side_effect = Exception("Connection limit exceeded")
            
            client = MockWebSocketClient("conv_limit", "user_limit", "Bearer token")
            
            with pytest.raises(Exception, match="Connection limit exceeded"):
                # This would normally use real websockets.connect
                raise Exception("Connection limit exceeded")
    
    async def test_dead_connection_detection(self, mock_ws_client):
        """Test dead connection detection and cleanup."""
        await mock_ws_client.connect()
        
        # Simulate dead connection
        mock_ws_client.websocket.send.side_effect = ConnectionClosed(None, None)
        
        # Attempt to send message should detect dead connection
        with pytest.raises(ConnectionClosed):
            await mock_ws_client.send_message("Test message")
        
        # Connection should be marked as not connected
        assert not mock_ws_client.is_connected


@pytest.mark.integration
@pytest.mark.asyncio
class TestMessageFlow:
    """Test WebSocket message flow."""
    
    async def test_single_human_sends_nlweb_responds(self, mock_ws_client):
        """Test single human sends message, NLWeb responds."""
        await mock_ws_client.connect()
        
        # Human sends message
        sent_message = await mock_ws_client.send_message("What's the weather?", ["weather.com"])
        
        # Verify message was sent
        mock_ws_client.websocket.send.assert_called()
        call_args = mock_ws_client.websocket.send.call_args[0][0]
        sent_data = json.loads(call_args)
        
        assert sent_data["type"] == "message"
        assert sent_data["content"] == "What's the weather?"
        assert sent_data["sites"] == ["weather.com"]
        
        # Mock receiving NLWeb response
        mock_ws_client.websocket.recv.return_value = json.dumps({
            "type": "ai_response",
            "message_type": "nlws",
            "sequence_id": 2,
            "conversation_id": "conv_test_001",
            "content": "Today's weather is sunny with 75°F",
            "participant": {
                "participantId": "nlweb_1",
                "displayName": "AI Assistant",
                "type": "ai"
            }
        })
        
        # Receive the response
        response = await mock_ws_client.websocket.recv()
        response_data = json.loads(response)
        
        assert response_data["type"] == "ai_response"
        assert response_data["message_type"] == "nlws"
        assert "weather" in response_data["content"]
    
    async def test_multiple_humans_send_simultaneously(self, multiple_mock_clients):
        """Test multiple humans sending messages simultaneously."""
        # Connect all clients
        for client in multiple_mock_clients:
            await client.connect()
        
        # Send messages simultaneously
        send_tasks = []
        for i, client in enumerate(multiple_mock_clients):
            task = client.send_message(f"Message from user {i}")
            send_tasks.append(task)
        
        # Wait for all sends to complete
        sent_messages = await asyncio.gather(*send_tasks)
        
        # Verify all messages were sent
        assert len(sent_messages) == 3
        for i, message in enumerate(sent_messages):
            assert f"Message from user {i}" in message["content"]
    
    async def test_message_ordering_via_sequence_ids(self, mock_ws_client):
        """Test message ordering via sequence IDs."""
        await mock_ws_client.connect()
        
        # Send multiple messages
        messages = []
        for i in range(5):
            msg = await mock_ws_client.send_message(f"Message {i}")
            messages.append(msg)
        
        # Mock receiving ordered responses
        received_messages = []
        for i in range(5):
            mock_response = {
                "type": "message",
                "sequence_id": i + 1,
                "content": f"Response to message {i}",
                "conversation_id": "conv_test_001"
            }
            received_messages.append(mock_response)
        
        # Verify sequence IDs are sequential
        sequence_ids = [msg["sequence_id"] for msg in received_messages]
        assert sequence_ids == list(range(1, 6))
    
    async def test_typing_indicators_throttled(self, mock_ws_client):
        """Test typing indicators are throttled."""
        await mock_ws_client.connect()
        
        # Send rapid typing indicators
        typing_times = []
        for i in range(5):
            start_time = time.time()
            await mock_ws_client.send_typing(True)
            typing_times.append(time.time() - start_time)
            await asyncio.sleep(0.1)  # Short delay
        
        # In real implementation, would verify throttling
        # For now, just verify calls were made
        assert mock_ws_client.websocket.send.call_count >= 5
    
    async def test_ai_response_streaming(self, mock_ws_client):
        """Test AI response streaming."""
        await mock_ws_client.connect()
        
        # Send message that triggers streaming response
        await mock_ws_client.send_message("Generate a long response")
        
        # Mock receiving streaming chunks
        streaming_chunks = [
            {"type": "ai_chunk", "content": "This is "},
            {"type": "ai_chunk", "content": "a streaming "},
            {"type": "ai_chunk", "content": "response."}
        ]
        
        # Simulate receiving chunks
        for chunk in streaming_chunks:
            mock_ws_client.websocket.recv.return_value = json.dumps(chunk)
            received = await mock_ws_client.websocket.recv()
            chunk_data = json.loads(received)
            
            assert chunk_data["type"] == "ai_chunk"
            assert "content" in chunk_data


@pytest.mark.integration
@pytest.mark.asyncio
class TestSyncMechanism:
    """Test WebSocket sync mechanism after reconnection."""
    
    async def test_reconnect_with_last_sequence_id(self, mock_ws_client):
        """Test reconnection with last sequence ID for sync."""
        # Initial connection and receive some messages
        await mock_ws_client.connect()
        
        # Simulate receiving messages and tracking sequence ID
        for i in range(3):
            await mock_ws_client.receive_message()
        
        assert mock_ws_client.last_sequence_id == 3
        
        # Simulate disconnection
        await mock_ws_client.simulate_network_interruption()
        
        # Reconnect and sync
        await mock_ws_client.connect()
        await mock_ws_client.send_sync_request()
        
        # Verify sync request includes last sequence ID
        sync_call = mock_ws_client.websocket.send.call_args_list[-1]
        sync_data = json.loads(sync_call[0][0])
        
        assert sync_data["type"] == "sync"
        assert sync_data["last_sequence_id"] == 3
    
    async def test_receive_only_missed_messages(self, mock_ws_client):
        """Test receiving only missed messages after sync."""
        await mock_ws_client.connect()
        
        # Set last known sequence ID
        mock_ws_client.last_sequence_id = 5
        
        # Send sync request
        await mock_ws_client.send_sync_request()
        
        # Mock receiving sync response with missed messages
        sync_response = {
            "type": "sync",
            "messages": [
                {"sequence_id": 6, "content": "Missed message 1"},
                {"sequence_id": 7, "content": "Missed message 2"},
                {"sequence_id": 8, "content": "Missed message 3"}
            ],
            "current_sequence_id": 8,
            "participants": [
                {"participantId": "user_1", "displayName": "User 1"},
                {"participantId": "user_2", "displayName": "User 2"}
            ]
        }
        
        mock_ws_client.websocket.recv.return_value = json.dumps(sync_response)
        response = await mock_ws_client.websocket.recv()
        response_data = json.loads(response)
        
        # Verify sync response
        assert response_data["type"] == "sync"
        assert len(response_data["messages"]) == 3
        assert response_data["current_sequence_id"] == 8
        
        # Verify only messages after last_sequence_id are included
        for msg in response_data["messages"]:
            assert msg["sequence_id"] > 5
    
    async def test_participant_list_sync(self, mock_ws_client):
        """Test participant list synchronization."""
        await mock_ws_client.connect()
        await mock_ws_client.send_sync_request()
        
        # Mock sync response with updated participant list
        sync_response = {
            "type": "sync",
            "messages": [],
            "current_sequence_id": 10,
            "participants": [
                {
                    "participantId": "user_1",
                    "displayName": "Alice",
                    "type": "human",
                    "isOnline": True,
                    "joinedAt": "2024-01-01T10:00:00Z"
                },
                {
                    "participantId": "user_2", 
                    "displayName": "Bob",
                    "type": "human",
                    "isOnline": False,
                    "joinedAt": "2024-01-01T10:05:00Z"
                },
                {
                    "participantId": "nlweb_1",
                    "displayName": "AI Assistant",
                    "type": "ai",
                    "isOnline": True,
                    "joinedAt": "2024-01-01T10:00:00Z"
                }
            ]
        }
        
        mock_ws_client.websocket.recv.return_value = json.dumps(sync_response)
        response = await mock_ws_client.websocket.recv()
        response_data = json.loads(response)
        
        # Verify participant list sync
        assert len(response_data["participants"]) == 3
        participant_types = {p["type"] for p in response_data["participants"]}
        assert participant_types == {"human", "ai"}
    
    async def test_no_duplicate_messages(self, mock_ws_client):
        """Test no duplicate messages during sync."""
        await mock_ws_client.connect()
        
        # Receive initial messages
        initial_messages = []
        for i in range(3):
            msg = await mock_ws_client.receive_message()
            initial_messages.append(json.loads(msg))
        
        # Simulate reconnect and sync
        await mock_ws_client.simulate_network_interruption()
        await mock_ws_client.connect()
        await mock_ws_client.send_sync_request()
        
        # Mock sync response (should not include already received messages)
        sync_response = {
            "type": "sync",
            "messages": [
                {"sequence_id": 4, "content": "New message 1"},
                {"sequence_id": 5, "content": "New message 2"}
            ],
            "current_sequence_id": 5
        }
        
        mock_ws_client.websocket.recv.return_value = json.dumps(sync_response)
        response = await mock_ws_client.websocket.recv()
        response_data = json.loads(response)
        
        # Verify no duplicates
        sync_seq_ids = [msg["sequence_id"] for msg in response_data["messages"]]
        initial_seq_ids = [msg["sequence_id"] for msg in initial_messages]
        
        # No overlap between initial and sync messages
        assert not set(sync_seq_ids).intersection(set(initial_seq_ids))


@pytest.mark.integration
@pytest.mark.asyncio
class TestBroadcastTests:
    """Test WebSocket broadcast functionality."""
    
    async def test_three_humans_two_ai_agents_scenario(self):
        """Test scenario with 3 humans + 2 AI agents."""
        # Create participants
        humans = [
            MockWebSocketClient("conv_broadcast", f"human_{i}", f"Bearer token_h{i}")
            for i in range(3)
        ]
        
        # Connect all humans
        for human in humans:
            await human.connect()
        
        # Simulate AI agents (they don't have WebSocket connections)
        ai_agents = ["nlweb_1", "nlweb_2"]
        
        # Human sends message
        sender = humans[0]
        await sender.send_message("Hello everyone!")
        
        # Mock broadcast to all participants
        broadcast_message = {
            "type": "message",
            "sequence_id": 1,
            "sender_id": "human_0",
            "content": "Hello everyone!",
            "conversation_id": "conv_broadcast"
        }
        
        # Verify all humans would receive the message
        for human in humans[1:]:  # Exclude sender
            human.websocket.recv.return_value = json.dumps(broadcast_message)
            received = await human.websocket.recv()
            received_data = json.loads(received)
            
            assert received_data["content"] == "Hello everyone!"
            assert received_data["sender_id"] == "human_0"
    
    async def test_all_participants_receive_all_messages(self, multiple_mock_clients):
        """Test that all participants receive all messages."""
        # Connect all clients
        for client in multiple_mock_clients:
            await client.connect()
        
        # Each client sends a message
        sent_messages = []
        for i, client in enumerate(multiple_mock_clients):
            msg = await client.send_message(f"Message from user {i}")
            sent_messages.append(msg)
        
        # Mock each client receiving all other messages
        for receiver in multiple_mock_clients:
            for sender_idx, sender in enumerate(multiple_mock_clients):
                if receiver != sender:
                    # Mock receiving message from other sender
                    broadcast_msg = {
                        "type": "message",
                        "sequence_id": sender_idx + 1,
                        "sender_id": f"user_{sender_idx}",
                        "content": f"Message from user {sender_idx}",
                        "conversation_id": "conv_multi_001"
                    }
                    
                    receiver.websocket.recv.return_value = json.dumps(broadcast_msg)
                    received = await receiver.websocket.recv()
                    received_data = json.loads(received)
                    
                    assert received_data["sender_id"] == f"user_{sender_idx}"
    
    async def test_o_n_broadcast_performance(self, multiple_mock_clients):
        """Test O(N) broadcast performance."""
        # Connect multiple clients
        for client in multiple_mock_clients:
            await client.connect()
        
        participant_count = len(multiple_mock_clients)
        
        # Measure broadcast simulation time
        start_time = time.time()
        
        # Simulate broadcasting one message to all participants
        message = {"type": "message", "content": "Broadcast test"}
        
        # In real implementation, this would be O(N) operation
        broadcast_tasks = []
        for client in multiple_mock_clients:
            # Mock the broadcast operation
            task = asyncio.create_task(client.websocket.send(json.dumps(message)))
            broadcast_tasks.append(task)
        
        await asyncio.gather(*broadcast_tasks)
        
        broadcast_time = time.time() - start_time
        
        # Verify performance is reasonable (O(N) not O(N²))
        assert broadcast_time < 0.1  # Should be very fast for small N
        
        # In real tests, would verify time scales linearly with N
    
    async def test_selective_delivery_failures(self, multiple_mock_clients):
        """Test handling selective delivery failures."""
        # Connect all clients
        for client in multiple_mock_clients:
            await client.connect()
        
        # Simulate one client having connection issues
        failing_client = multiple_mock_clients[1]
        failing_client.websocket.send.side_effect = ConnectionClosed(None, None)
        
        # Attempt broadcast to all
        message = {"type": "message", "content": "Test delivery failure"}
        
        delivery_results = []
        for client in multiple_mock_clients:
            try:
                await client.websocket.send(json.dumps(message))
                delivery_results.append(True)
            except ConnectionClosed:
                delivery_results.append(False)
        
        # Verify partial delivery
        assert delivery_results[0] is True   # First client succeeds
        assert delivery_results[1] is False  # Second client fails
        assert delivery_results[2] is True   # Third client succeeds
        
        # Conversation should continue for working clients
        working_clients = [c for i, c in enumerate(multiple_mock_clients) if delivery_results[i]]
        assert len(working_clients) == 2


@pytest.mark.integration
@pytest.mark.asyncio
class TestWebSocketErrorHandling:
    """Test WebSocket error handling scenarios."""
    
    async def test_queue_full_429_response(self, mock_ws_client):
        """Test queue full (429) response."""
        await mock_ws_client.connect()
        
        # Mock queue full error response
        error_response = {
            "type": "error",
            "code": "QUEUE_FULL",
            "message": "Conversation queue is full. Please try again later.",
            "retry_after": 5
        }
        
        mock_ws_client.websocket.recv.return_value = json.dumps(error_response)
        
        # Send message that would trigger queue full
        await mock_ws_client.send_message("This should trigger queue full")
        
        # Receive error response
        response = await mock_ws_client.websocket.recv()
        error_data = json.loads(response)
        
        assert error_data["type"] == "error"
        assert error_data["code"] == "QUEUE_FULL"
        assert "retry_after" in error_data
    
    async def test_invalid_message_format(self, mock_ws_client):
        """Test invalid message format handling."""
        await mock_ws_client.connect()
        
        # Send invalid message format
        invalid_message = '{"invalid": "json"'  # Malformed JSON
        
        # Mock error response for invalid format
        mock_ws_client.websocket.recv.return_value = json.dumps({
            "type": "error",
            "code": "INVALID_FORMAT",
            "message": "Invalid message format"
        })
        
        # In real implementation, server would reject invalid JSON
        try:
            await mock_ws_client.websocket.send(invalid_message)
        except Exception:
            pass  # Expected for malformed JSON
        
        # Receive error response
        error_response = await mock_ws_client.websocket.recv()
        error_data = json.loads(error_response)
        
        assert error_data["code"] == "INVALID_FORMAT"
    
    async def test_authentication_failure(self):
        """Test WebSocket authentication failure."""
        # Create client with invalid token
        invalid_client = MockWebSocketClient("conv_test", "user_test", "Bearer invalid_token")
        
        # Mock authentication failure
        with patch.object(invalid_client, 'connect') as mock_connect:
            mock_connect.side_effect = InvalidHandshake(None, "Authentication failed")
            
            with pytest.raises(InvalidHandshake):
                await invalid_client.connect()
    
    async def test_network_interruption(self, mock_ws_client):
        """Test network interruption handling."""
        await mock_ws_client.connect()
        
        # Simulate network interruption
        await mock_ws_client.simulate_network_interruption()
        
        # Attempt to send message should fail
        with pytest.raises(ConnectionClosed):
            await mock_ws_client.send_message("This should fail")
        
        # Client should detect disconnection
        assert not mock_ws_client.is_connected
    
    async def test_participant_limit_exceeded(self, mock_ws_client):
        """Test participant limit exceeded error."""
        await mock_ws_client.connect()
        
        # Mock participant limit error
        limit_error = {
            "type": "error",
            "code": "PARTICIPANT_LIMIT_EXCEEDED",
            "message": "Maximum participants (100) reached for this conversation",
            "current_count": 100,
            "limit": 100
        }
        
        mock_ws_client.websocket.recv.return_value = json.dumps(limit_error)
        
        # Receive error when trying to join full conversation
        error_response = await mock_ws_client.websocket.recv()
        error_data = json.loads(error_response)
        
        assert error_data["code"] == "PARTICIPANT_LIMIT_EXCEEDED"
        assert error_data["current_count"] == 100
        assert error_data["limit"] == 100


@pytest.mark.integration
@pytest.mark.asyncio
class TestWebSocketClientUtilities:
    """Test WebSocket client utility functions."""
    
    async def test_mock_handshake(self, mock_ws_client):
        """Test mock WebSocket handshake."""
        # Test successful handshake
        success = await mock_ws_client.connect()
        
        assert success is True
        assert mock_ws_client.websocket is not None
        assert mock_ws_client.is_connected is True
    
    async def test_message_sending_receiving(self, mock_ws_client):
        """Test message sending and receiving utilities."""
        await mock_ws_client.connect()
        
        # Test sending
        sent_message = await mock_ws_client.send_message("Test message")
        assert sent_message["content"] == "Test message"
        assert sent_message["type"] == "message"
        
        # Test receiving
        received_message = await mock_ws_client.receive_message()
        received_data = json.loads(received_message)
        assert received_data["type"] == "message"
        assert "content" in received_data
    
    async def test_reconnection_simulation(self, mock_ws_client):
        """Test reconnection simulation utilities."""
        # Initial connection
        await mock_ws_client.connect()
        initial_attempts = mock_ws_client.connection_attempts
        
        # Simulate disconnection
        await mock_ws_client.simulate_network_interruption()
        assert not mock_ws_client.is_connected
        
        # Simulate reconnection
        await mock_ws_client.connect()
        assert mock_ws_client.is_connected
        assert mock_ws_client.connection_attempts > initial_attempts
    
    async def test_latency_measurement(self, mock_ws_client):
        """Test latency measurement utilities."""
        await mock_ws_client.connect()
        
        # Measure message round-trip time
        start_time = time.perf_counter()
        
        # Send message
        await mock_ws_client.send_message("Latency test")
        
        # Mock receiving response
        mock_ws_client.websocket.recv.return_value = json.dumps({
            "type": "message",
            "content": "Response to latency test",
            "timestamp": datetime.utcnow().isoformat()
        })
        
        # Receive response
        await mock_ws_client.websocket.recv()
        
        round_trip_time = time.perf_counter() - start_time
        
        # In real implementation, would measure actual network latency
        # For testing, just verify measurement mechanism works
        assert round_trip_time >= 0
        assert round_trip_time < 1.0  # Should be very fast for mocked calls


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-m", "integration"])